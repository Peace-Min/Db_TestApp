# SQLite 저널링 모드 성능 비교: 트랜잭션 당 레코드 수의 비밀

## 🎯 핵심 요약

| 트랜잭션 당 레코드(N) | 승자 | 결정적 이유 (Cost) |
| :--- | :--- | :--- |
| **극소량 (N=1)** | 🏆 **WAL** | `B-Tree 탐색/랜덤 I/O` >>> `Checksum + Append` |
| **대량 (N=10,000)** | 🏆 **MEMORY** | `B-Tree 탐색/랜덤 I/O` <<< `Checksum + Append` |

> **"트랜잭션 오버헤드(Seek)와 데이터 처리 오버헤드(Checksum)의 줄다리기 싸움"**

---

## 1. 📉 N=1 (극단적인 트랜잭션 오버헤드)

**상황**: `BEGIN` -> `INSERT 1개` -> `COMMIT` (10,000번 반복)

### 🐌 MEMORY 모드 (패배)
- **작업**: 매 트랜잭션마다 **"어디에 넣지?"(B-Tree 탐색/Seek)** 수행.
- **비용**: 디스크 헤드를 움직이는 **I/O 포지셔닝 비용**이 10,000번 발생.
- **특징**: 데이터 쓰는 시간보다 위치 찾는 시간이 더 걸림. (배보다 배꼽이 큼)

### 🚀 WAL 모드 (승리)
- **작업**: 매 트랜잭션마다 **"그냥 맨 뒤에 붙여"(Append)** 수행. (탐색 0)
- **비용**: 1개 데이터에 대한 **Checksum 계산** + 쓰기.
- **결과**: `B-Tree 탐색 비용` >>> `1개 Checksum 비용` → **WAL 압승!**

---

## 2. 📈 N=10,000 (대량 배치 처리)

**상황**: `BEGIN` -> `INSERT 10,000개` -> `COMMIT` (1번 수행)

### 🚀 MEMORY 모드 (승리)
- **작업**: 10,000개 데이터를 메모리에서 정렬 후, 디스크 위치 **딱 1번 잡고(Seek)** 쏟아부음.
- **비용**: `1회 탐색` 비용은 10,000개 데이터 처리 전체에서 미미함. (희석됨)
- **특징**: **데이터에 대한 Checksum 계산을 안 함.** (순수 쓰기 속도)

### 🐌 WAL 모드 (패배)
- **작업**: 10,000개 데이터를 맨 뒤에 씀. (탐색 0)
- **비용**: **데이터 10,000개 분량 전체에 대해 Page 단위 Checksum 계산 & 헤더 부착.**
- **결과**: `1회 탐색 비용` <<< `10,000개 분량 Checksum 비용` → **MEMORY 승리!**

---

## 💡 최종 정리 (User's Insight)

> **"트랜잭션 당 레코드 수가 적을 때(N=1)는 `트랜잭션(커밋) 단위의 B-Tree 탐색 오버헤드`가 지배적이어서 WAL이 유리하고,"**
>
> **"트랜잭션 당 레코드 수가 많을 때(N=10,000)는 `데이터 비례 Checksum 오버헤드`가 지배적이어서 MEMORY가 유리하다."**
