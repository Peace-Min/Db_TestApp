# SQLite WAL 모드 성능 및 Checkpoint 전략 완벽 가이드

이 문서는 고성능 실시간 시뮬레이션 환경에서 SQLite WAL 모드를 사용할 때 발생하는 **성능 오버헤드의 원인**, **Checkpoint 전략의 득실**, 그리고 **최적의 아키텍처**를 누구나 쉽게 이해하고 설명할 수 있도록 정리한 자료입니다.

---

## 1. 성능 이슈의 핵심: "왜 Reader가 있으면 느려지는가?"

테스트에서 Reader(읽기)가 붙었을 때 Writer(쓰기) 성능이 약 15% 저하되는 현상이 있었습니다.

### 🔍 원인 분석: "논리적 Lock이 아닌 물리적 자원 전쟁"
SQLite의 WAL 모드는 이론적으로 **Reader와 Writer가 서로를 기다리지 않습니다(No Locking).** 하지만 현실 세계의 컴퓨터 자원은 한정되어 있어 **세 가지 병목**이 발생했습니다.

1.  **CPU & 스케줄링 점유**:
    *   Reader가 `Sleep` 없이 무한 루프(`while(true)`)를 돌면 CPU 코어 하나를 100% 점유합니다.
    *   OS 스케줄러는 Writer에게 줄 CPU 시간 조각(Time Slice)을 줄일 수밖에 없습니다.
    *   **해결:** Reader에 아주 미세한 `Thread.Sleep(1)`만 줘도 Writer가 숨 쉴 틈이 생겨 성능이 원상 복구됩니다.
2.  **메모리 버스 & 캐시 경합**:
    *   Reader가 엄청난 속도로 메모리를 읽어대면, Writer가 데이터를 쓸 때 필요한 메모리 대역폭이 줄어듭니다.
3.  **SHM(Shared Memory) Spinlock**:
    *   WAL 내부 관리를 위한 `-shm` 파일에 초당 수천 번씩 접근하므로, 아주 미세한 스핀락(Spinlock) 대기 시간이 티끌 모아 태산이 되어 전체 시간을 지연시킵니다.

> **한 줄 요약:** "Reader가 Writer의 멱살을 잡은 게 아니라, Reader가 너무 바빠서 Writer가 비집고 들어갈 틈이 없었던 것이다."

---

## 2. Checkpoint(병합) 전략: "할 것인가 말 것인가?"

WAL 파일(`-wal`)에 쌓인 데이터를 원본 DB(`-db`)로 옮기는 작업을 **Checkpoint**라고 합니다.

### 🚀 시나리오: "1분 내외의 단기 시뮬레이션 / 몬테카를로 테스트"

이 시나리오에서는 **"중간 Checkpoint 안 함 (Disable Auto-Checkpoint)"**이 **최적의 전략**입니다.

### ✅ 전략 비교

| 구분 | **Auto-Checkpoint (기본값)** | **No Checkpoint (최적화)** |
| :--- | :--- | :--- |
| **동작 방식** | WAL이 4MB 찰 때마다 멈칫하며 원본에 병합 | **병합 없이 WAL 뒤에 계속 이어 붙임** |
| **쓰기 성능** | 주기적인 I/O 지연(Jitter) 발생 | **최고 속도 유지 (Zero-Latency)** |
| **읽기 성능** | 항상 빠름 | 데이터가 커질수록 조금 느려짐 (메모리 탐색 비용↑) |
| **자원 사용** | WAL 파일 크기가 작게 유지됨 | **WAL 파일이 계속 커짐 (수백 MB)** |
| **파일 관리** | `.db` 파일 하나만 관리하면 됨 | **`.db`, `.wal`, `.shm` 3개를 세트로 관리해야 함** |

### 💡 왜 "No Checkpoint"가 정답인가?
1.  **쓰기 속도 최우선:** 시뮬레이션 중단 없이 데이터를 쏟아붓는 게 가장 중요합니다.
2.  **부작용 미미함:** 1분 정도의 데이터(수백 MB)는 WAL 인덱스가 메모리에서 충분히 커버 가능하므로 읽기 속도 저하가 없습니다.
3.  **관리 가능:** 시뮬레이션이 끝나고 **딱 한 번만 정리**하면 됩니다.

---

---

## 3. 핵심 쟁점 심층 분석: "Write SW 성능 절대 사수"

사용자의 핵심 요구사항인 **"Write SW의 성능을 1ms라도 늦추지 않는 것"**에 대한 기술적 검증 내용입니다.

### ✅ Write SW 관점: "절대적 성능 보장 (O(1))"
Checkpoint를 끄면(`wal_autocheckpoint=0`), **Write SW의 성능 저하는 수학적으로 "0"에 수렴합니다.**
*   **이유:** Writer는 WAL 파일이 1GB든 10GB든 상관없이, 오직 **맨 끝에 데이터를 이어 붙이기(Append-Only)**만 합니다.
*   **복잡도:** 기존 데이터 양(N)과 무관하게 항상 일정 시간(**O(1)**)이 소요됩니다.
*   따라서, **Reader가 붙든 WAL이 커지든 Write 성능은 완벽하게 격리되어 보호됩니다.** (단, 디스크 용량 충분 시)

### ✅ Reader SW 관점: "대용량 WAL 감당 가능한가?"
*"10분 시뮬레이션으로 WAL이 수 GB가 되어도 괜찮은가?"* -> **"네, 충분히 괜찮습니다."**
*   **WAL-Index의 마법:** SQLite는 `-shm`(메모리 맵) 파일을 통해 거대한 WAL 파일 속에서도 데이터 위치를 **해시 테이블(Hash Table)**로 즉시 찾습니다.
*   **Low Cost:** 파일 전체를 스캔하는 것이 아니라 인덱스를 타고 점프하므로, 수 GB 크기에서도 조회 속도 저하는 **사람이 인지하기 힘든 수준(Micro-seconds)**입니다.
*   **결론:** 시뮬레이션 모니터링 용도의 Reader 성능은 WAL 크기에 거의 영향을 받지 않습니다.

---

## 4. 안정성 및 유연성 검토

### ❓ "시뮬레이션이 비정상 종료되어서 Checkpoint를 못 하면 어떡하죠?"
**걱정하실 필요 없습니다. 기능상 완벽히 안전합니다.**

*   **정상 종료 시:**
    *   프로그램 종료 루틴에서 `Checkpoint(TRUNCATE)`를 호출하여 WAL을 비우고 깔끔한 `.db` 파일을 만듭니다.
*   **비정상 종료 시 (Crash):**
    *   Checkpoint를 못 해도, 디스크에는 **최신 내용이 담긴 `-wal` 파일**이 그대로 살아있습니다.
    *   나중에(또는 다른 툴로) DB를 여는 순간, SQLite가 자동으로 "어, WAL이 있네?" 하고 복구 모드로 읽습니다.
    *   **단점:** 처음에 DB 열 때 몇 초 정도 복구 시간이 더 걸릴 뿐, **데이터 유실은 0%**입니다.

---

## 4. 최종 추천 아키텍처 (Best Practice)

가장 유연하고 강력한 성능을 내는 구조입니다.

1.  **시작 (INIT):**
    *   `PRAGMA journal_mode = WAL;`
    *   `PRAGMA synchronous = NORMAL;` (안전과 속도의 타협점)
    *   `PRAGMA wal_autocheckpoint = 0;` **(중간 병합 끄기 = 성능 부스터 ON)**
2.  **실행 (RUN):**
    *   Reader는 필요할 때만 조회 (너무 잦은 무한 루프는 `Sleep(1)` 등으로 제어)
    *   Writer는 방해 없이 데이터 고속 적재
3.  **종료 (FINISH):**
    *   `try { PRAGMA wal_checkpoint(TRUNCATE); } catch { ... }`
    *   (성공 시) 깔끔한 `.db` 파일 생성됨.
    *   (실패/Crash 시) `.wal` 파일이 남지만 데이터는 안전함.

이 가이드를 통해 SQLite의 동작을 완벽히 제어하고 있음을 팀원들에게 자신 있게 설명할 수 있습니다.
